<meta charset=utf-8>
<style>
main {
	font-family: arial;
	text-align: center;
}
h1 {
	margin-top: 5em;
}
mark {
	background: #fe5;
	padding: 3px;
}
p {
	margin: 3px auto;
}
pre {
	font-family: courier;
	margin: auto;
	background: #def;
	padding: 15px;
	border-radius: 10px;
	white-space: pre-wrap;
	max-width: 780px;
}
#grid {
	display: grid;
	grid-auto-flow: column;
	grid-template-rows: repeat(5, 1fr);
	grid-gap: 0px;
	grid-auto-rows: minmax(2.8em, auto);
	margin-top: 3em;
	border-width: 1px;
	border-style: inset;
	border-color: initial;
	border-image: initial;
}
form {
	margin: 0;
	padding: 0;
	display: inline-grid;
}
input {
	font-size: 1.5em;
	min-width: 40px;
}
footer {
	margin-top: 5em;
}
</style>

<main>

<h1>Sheet</h1>

<p><a href=//github.com/xem/sheet>inspired by this golfing</a></p>


<section>

	<p>Cells can contain text, numbers or formulas.</p>
	<p>Formulas start with =. Example: "=A1+8*B2".</p>

	<div id="grid"></div>

</section>

<script>
		const a = "ABCDE";
		const graph = {}; // id => {refs: setOfIds, deps: setOfIds, cell: currentCell, value: initalValue}


		const calc = (id, callers = new Set()) => { // callers is to avoid loops
			const node = graph[id];
			const cellValue = node.cell.value.trim();
			const value = node.value!==undefined ? node.value : cellValue;

			if (value[0] === '='){
				node.value = value;
				const refs = value.match(/[A-Z]\d/g) || [];

				// update graph
				node.refs = new Set(refs);
				refs.forEach(x => {
					graph[x].deps.add(id);
				});

				if (callers.has(id)) {
					node.cell.value = '#REF';
					return value;
				}

				callers.add(id);
				try {
					const evaling = value.slice(1).replace(/[A-Z]\d/g, x => calc(x, callers));
					const evaled = eval(evaling);
					node.cell.value = evaled;
					return evaled;
				} catch(e){
					node.cell.value = NaN;
					console.error(e);
					return NaN;
				}
			}
			return value || 0;
		};

		// update deps, using just computed values
		const update = id => {
			const node = graph[id];
			node.deps.forEach(x => {
				const n = graph[x];
				try {
					n.cell.value = eval(n.value.trim().slice(1).replace(/[A-Z]\d/g, r => graph[r].cell.value));
				} catch(e) {
					n.cell.value = NaN;
				}
				update(x); // recurse down
			});
		};

		for (const j in a) {
			for (const i in a) {
				const id = a[j]+(+i+1);
				const input = document.createElement('input');
				input.id = input.placeholder = id;
				input.onchange = e => {
					graph[e.target.id].value = undefined;
				};
				input.onfocus = e => { // show formula if any
					e.target.value = graph[e.target.id].value || e.target.value
				};
				input.onblur = e => {
					calc(e.target.id);
					// update deps
					update(e.target.id);
				}
				input.onkeydown = e => {
					if (e.key !== 'Enter') return;
					calc(e.target.id);
					update(e.target.id);
					// focus next cell
					const next = input.nextElementSibling || grid.firstElementChild;
					next.focus();
				};
				grid.append(input);
				graph[id] = { refs: new Set(), deps: new Set(), cell: input };
			}
		}
</script>


</main>