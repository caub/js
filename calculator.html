

<script>

var operators={ // precedence
	'*': 3,
	'/': 3,
	'+': 4,
	'-': 4
};

function parse(tokens){
	
	var tree={};
	var last = tree;
	var parMatch = false;

	tokens.forEach(function(token, kForDebugging){

		//console.log(tree, JSON.stringify(tree, null, 4))
		// going down the rights branch and see where to add the token
		var node = tree, candidates=[];
		while(node.hasOwnProperty('right')){
			candidates.push(node);
			node = node.right;
		}
		candidates.push(node);
		
		if (!isNaN(+token)){ // number
			if (!node.hasOwnProperty('value')){
				node.value = token;
				return;
			}
			node.right = {
				value: token
			};
			
		} else if (token == '(') {
			if (!last.hasOwnProperty('value')){ // it's a starting parenthesis
				last.par=1;
			}else{
				if (!last.hasOwnProperty('right')){
					last.right={};
					//console.log('ADDED LAST RIGHT (')
				}
				if (!last.right.hasOwnProperty('par'))
					last.right.par=0;
				last.right.par++;
			}
			//console.log('((((', last)
		} else if (token == ')') {
			// find first matching parenthesis
			var i= candidates.length-1;
			while (i>=1 && 
				   (!candidates[i-1].hasOwnProperty('par') || candidates[i-1].par<=0 ) ){
				i--;
			}
			//console.log('))))', candidates[i-1])
			candidates[i-1].par--;
			parMatch = candidates[i-1];

		} else if (token in operators) {
			//console.log(token, candidates)
			if (candidates.length==1 && !node.hasOwnProperty('left')) { // init
				node.left = { value: node.value };
				node.value = token;
				return
			}
			// look from the right of candidate, the first positive par
			var i= candidates.length-1;
			//console.log(token, node, i, candidates[i], candidates.length, operators[token], operators[candidates[i-1].value])

			if (parMatch){ // starts above parMatch
				while (i>=1 && candidates[i-1]!==parMatch ){
					i--;
				}
				i--;
				//debugger;
				parMatch = false;
			}

			while (i>=1 && operators[token]>=operators[candidates[i-1].value] && 
				   (!candidates[i].hasOwnProperty('par') || candidates[i].par<=0 ) ){
				i--;
			}

			//console.log(i, candidates[i])
			node = candidates[i];

			var hasPar = node.hasOwnProperty('par');
			var par = hasPar?node.par:0;
			if (hasPar) node.par=0;
			
			if (i>0){	
				candidates[i-1].right = last = {
					value: token,
					left: node
				};
			}else{
				tree = {
					value: token,
					left: tree
				};
				last = tree;
			}
			if (hasPar) last.par = par;
		}

	})
	
	return tree;
}

function eval2(tree){
	if (!isNaN(+tree.value))
		return +tree.value;
	if (tree.value=='+')
		return eval2(tree.left) + eval2(tree.right)
	else if (tree.value=='-')
		return eval2(tree.left) - eval2(tree.right)
	else if (tree.value=='*')
		return eval2(tree.left) * eval2(tree.right)
	else if (tree.value=='/')
		return eval2(tree.left) / eval2(tree.right)
}

var testCases =  [
	"2 * (4+2)",
	// "2*  3 +4+3 *8*(7+1) + 6",
	// "(1+2)*3+5*(4*6)",
	// "(1+2)*3+6*5*(2*3)",
	// "1+ (2*(4+3)+6)*8",
	// "(4+5) + ((2*(1+3)+4)*4+5)*4 +5*6",
	// "2*(4 - 2 -5) *6 +24 /5",
	// "2+((9-4/7)*2-1)-18*(14/4/(2*(3+5)))"
]

testCases.forEach(function(s){
	var tree = parse(s.match(/\d+|[+*-/()]/g))

	console.log(tree, JSON.stringify(tree, null, 4))

	console.log(eval2(tree), eval(s))
})



</script>