<h1>List removable forks</h1>
<style>
body {
	font-family: arial;
}
h1 {
	text-align: center;
	margin-top: 3em;
	margin-bottom: 2em;
}
input {
	font-size: 1.5em;
	margin: .5em auto;
}
input[type=submit] {
	background: transparent;
	border: 1px solid gray;
	font-feature-settings: 'liga' 1;
	padding: 5px 10px;
}
form {
	position: relative;
	display: flex;
	flex-direction: column;
	align-items: center;
}
#output {
	max-width: 800px;
	margin: 1em auto;
}
nav {
	display: flex;
	flex-direction: column;
	padding-left: 2em;
}
</style>
<form>
	<input name="login" placeholder="Github login, ex: mdo" required>
	<input name="token" placeholder="Github API token" required>
	<input type="submit" value="🔍">
</form>

<div id="output">
	
</div>

<script>
/*
create token: https://developer.github.com/v4/guides/forming-calls/#authenticating-with-graphql
*/
const link = url => `<a href="${url}">${url}</a>`;
const getAuthor = target => target.committedViaWeb ? target.author : target.committer;

const form = document.forms[0];

/* levels:
- 0: no branch from you -> safely removable
- 1: at most a branch with a CLOSED/MERGED PR -> quite safe, but you may want to check the closed ones
- 2: a branch with no PR -> could be removed, but check this branch first
- 3: an OPEN PR -> don't remove, or check it if you want to close it (if old)
*/


if (localStorage.ghToken) {
	form.token.value = localStorage.ghToken;
}

form.onsubmit = async e => {
	e.preventDefault();
	const login = form.login.value;
	localStorage.ghToken = form.token.value;
	try {
		const removables = []; // {name, parent, lvl (0: , 1 no branch from you, 2: branch without PR, 3: branch with a closed or merged PR)}
		let user;
		let cursor;
		for (let i=0; i<100; i++) {
			user = await getForks({login, after: cursor});
			const forks = user.repositories.nodes;
			console.log(forks.length);

			// inspect every fork, and see if it's safe to remove
			for (const fork of forks) {
				const refs = fork.refs.nodes;
				if (fork.refs.pageInfo.hasNextPage) {
					refs.push(...await getAllRefs({owner: login, name: fork.name, after: fork.refs.pageInfo.endCursor}));
				}
				// console.log(fork.name, refs.length);
				const myBranches = fork.refs.nodes.filter(ref => getAuthor(ref.target).email === user.email);
				let lvl = 0;
				let branch; // one of the branch you didn't PR to check
				myBranches.forEach(br => {
					const prs = br.associatedPullRequests.nodes;
					if (!prs.length) { lvl = Math.max(lvl, 2); branch = br.name; }
					else if (prs.some(pr => pr.state === 'OPEN')) lvl = Math.max(lvl, 3);
					else lvl = Math.max(lvl, 1);
				});
				removables.push({name: fork.name, parent: fork.parent.nameWithOwner, lvl, ...lvl === 2 && {branch}}) // https://github.com/gitterHQ/gitter-demo-app/pulls/caub
			}
		
			cursor = user.repositories.pageInfo.endCursor;
			if (!user.repositories.pageInfo.hasNextPage) {
				break;
			}
		}

		const rems = removables.reduce((m, {lvl, ...rest}) => m.set(lvl, [...m.get(lvl)||[], rest]), new Map());
		output.innerHTML = `
<p>0: no branch from you -> safely removable</p>
<nav>
	${rems.get(0).map(({name}) => link(`https://github.com/${login}/${name}`)).join('')}
</nav>
<p>1: at most a branch with a CLOSED/MERGED PR -> quite safe, but you may want to check the closed ones</p>
<nav>
	${rems.get(1).map(({name, parent}) => link(`https://github.com/${parent}/pulls/${login}?q=is:closed`)).join('')}
</nav>
<p>2: a branch with no PR -> could be removed, but check this branch first</p>
<nav>
	${rems.get(2).map(({name, branch}) => link(`https://github.com/${login}/${name}/tree/${branch}`)).join('')}
</nav>
<p>3: an OPEN PR -> don't remove, or check it if you want to close it (if old)</p>
<nav>
	${rems.get(3).map(({name, parent}) => link(`https://github.com/${parent}/pulls/${login}`)).join('')}
</nav>
`;
	} catch(err) {
		output.innerHTML = `<a href="https://developer.github.com/v4/guides/forming-calls/#authenticating-with-graphql">${err && err.message || 'Create a GH token!'}</a>`
	}
};

const getAllRefs = async ({owner, name, after: intialAfter}) => {
	let after = intialAfter;
	const allRefs = [];
	for (let i=0;i<20;i++) {
		const {repository: {refs}} = await gql({
			query: `query getOtherRefs($owner: String!, $name: String!, $after: String) {
				repository(owner: $owner, name: $name) {
					refs(refPrefix: "refs/heads/", first: 50, after: $after) {
						${refsFragment}
					}
				}	
			}`,
			variables: {owner, name, after}
		});
		allRefs.push(...refs.nodes);
		after = refs.pageInfo.endCursor;
		if (!refs.pageInfo.hasNextPage) break;
	}
	return allRefs;
}

const refsFragment = 
`nodes {
	name
	target {
		... on Commit {
			author {email}
			committer{email}
			committedViaWeb
		}
		oid
	}
	associatedPullRequests(first: 20) {
		nodes {
			state
			url
			createdAt
		}
	}
}
pageInfo {
	endCursor
	hasNextPage
}`;

const getForks = ({login, after, first = 100}) => gql({
	query: `query getForks($login: String!, $first: Int, $after: String) {
  user(login: $login) {
    email
    repositories(first: $first, after: $after, isFork: true) {
      nodes {
				name
				parent {nameWithOwner}
				refs(refPrefix: "refs/heads/", first: 50) {
					${refsFragment}
				}
      }
      pageInfo {
				endCursor
				hasNextPage
      }
    }
  }
}`,
	variables: {
		login, first, after
	}
})
	.then(d => d.user)

/* // could also query this for the forks, and check if a a branch 'in doubt' got merged in master (example if you got write perm)
		parent {
			defaultBranchRef {
				name
				target {
					... on Commit { 
						history(first: 10) {
							nodes{
								oid
							}
							pageInfo {endCursor}
						}
					}
					commitUrl
				}
			}
		}

*/


const gql = ({query, variables}) => fetch('https://api.github.com/graphql', {
	method: 'POST',
	headers: {
		Authorization: `bearer ${localStorage.ghToken}`
	},
	body: JSON.stringify({
		query,
		variables
	})
})
	.then(async r => {
		if (!r.ok) {
			const d = await r.json();
			throw new Error(d.message);
		}
		return r.json().then(d => d.data);
	});
</script>
